# frozen_string_literal: true
require 'bundler/setup'
require 'bundler/dependency'
require 'bundler/injector'
require 'bundler/installer'
require 'pathname'
require 'tempfile'

# Provides methods to install, update and uninstall widgets and sources.
module Installable

  EXTENSION_TYPES = %w[widget source].freeze

  def install
    determine_type
    # CAUTION: ActiveRecord.attributes() returns a hash with string keys, not symbols!
    engine = @model.attributes
    @gem, @version = engine['name'], engine['version']
    options = {'source' => engine['download'], 'group' => @extension_type} # Injector uses a string-keyed option hash.
    # TODO: Validate @model against downloaded extension info (TBD)

    begin
      dep = Bundler::Dependency.new(@gem, @version, options)
      injector = Bundler::Injector.new([dep])

      # Injector._append_to expects Pathname objects instead of path strings.
      gemfile = Pathname.new(File.absolute_path('Gemfile'))
      lockfile = Pathname.new(File.absolute_path('Gemfile.lock'))

      new_deps = injector.inject(gemfile, lockfile)

    rescue Bundler::Dsl::DSLError => e
      bundler_error(e)
    end

    installer = Bundler::Installer.new(Bundler.root, Bundler.definition)
    installer.run({'jobs' => 5})

    refresh_runtime

    raise bundler_error unless installed?(@gem, @version)

    # TODO: Service registration etc.
  end

  # Checks whether the given extension resource is properly installed.
  # @param [String] gem The gem name that should be checked.
  # @param [String] version The version which should be installed.
  def installed?(gem, version)
    gem_present = Gem.loaded_specs.keys.any?(gem)
    if gem_present
      Gem.loaded_specs[gem].version === Gem::Version.new(version)
    else
      gem_present
    end
  end

  # Update the extension gem's version in the Gemfile. Use search/replace since Bundler has no clean API to update the Gemfile with a new version.
  def update
    determine_type
    engine = @model.attributes
    @gem, @version = engine['name'], engine['version']

    search = /gem "#{@gem}", "= [0-9].[0-9].[0-9]"/
    replace = "gem \"#{@gem}\", \"= #{@version}\""

    tmp = Tempfile.new(['Gemfile', '.tmp'], Rails.root.to_s + '/tmp')
    tmp.write(File.read(Rails.root.to_s + '/Gemfile').dup.gsub(search, replace))
    tmp.rewind
    FileUtils.copy(tmp, Rails.root.to_s + "/Gemfile")
    tmp.close!

    installer = Bundler::Installer.new(Bundler.root, new_definition(:gems => [@gem]))
    installer.run({'jobs' => 5})

    refresh_runtime
    puts "#{@gem} #{@version} is installed: #{installed?(@gem, @version)}"

    # TODO: service re-registration etc. necessary?
  end

  # Uninstalls an extension gem.
  def uninstall
    determine_type
    engine = @model.attributes
    @gem = engine['name']

    remove_from_gemfile
    # Create a new runtime to regenerate the lockfile and clean up stale dependencies.
    rt = Bundler::Runtime.new(Bundler.root, new_definition)
    rt.lock
    rt.clean

    # Reload the bundle environment so that Rails does not try to require files from the uninstalled gem.
    refresh_runtime

    # @FIXME: Loaded specs do still include the uninstalled gem, possibly due to class caching.
    # If the gem is no longer on the load path, it's probably safe to assume no load errors on further requests.
    # Is there a clean way to remove the gem from $LOADED_FEATURES during runtime?
    #raise StandardError.new("#{@gem} still on $LOAD_PATH") if in_load_path?
    # TODO: implement service de-registration and other cleanup
  end


  private

  # Ensure that this module is only used on classes that can actually be installed.
  def determine_type
    @extension_type = self.class.name.downcase.sub('resource', '')
    raise JSONAPI::Exceptions::InvalidResource unless EXTENSION_TYPES.include?(@extension_type)
  end

  # Removes this instance's @gem from Gemfile. Bundler has no remove method yet, so we need to search/replace.
  def remove_from_gemfile
    search_text = /gem "#{@gem}"/
    tmp = Tempfile.new(['Gemfile', '.tmp'])

    File.open(Bundler.default_gemfile, 'r') do |file|
      file.each_line do |line|
        tmp.write(line) unless line =~ search_text || line =~ /# Added/ || line =~/^\n$/ # Removes autogenerated lines
      end
    end

    tmp.rewind # Otherwise the pointer is at the end and nothing gets copied.
    FileUtils.copy(tmp, Bundler.default_gemfile)
    tmp.close!
  end

  # Cleans up the bundle and raises an exception in case there is an error during Bundler operations.
  # @param [Object] error An optional Error object that has the methods message and status_code.
  def bundler_error(error = nil)
    remove_from_gemfile # Roll back changes made to Gemfile
    rt = new_runtime
    rt.lock
    rt.clean
    msg = "Error while installing extension #{@gem})"
    msg += error.nil? ? ": #{error.message}, code: #{error.status_code}" : ""
    raise StandardError.new(msg)
  end

  # Resets the Bundler runtime to ensure that the Gemfile specs are loaded. Unfortunately, this has no effect on Rubygems
  # or $LOAD_PATH / $LOADED_FEATURES, but at least deals with Bundler inconsistencies.
  def refresh_runtime
    begin
      Bundler.reset!
      Bundler.require(*Rails.groups, *EXTENSION_TYPES)
    rescue Bundler::GemRequireError => e
      bundler_error(e)
    end
  end

  # Generates a new Bundler::Runtime whose definition is re-read from the Gemfile.
  def new_runtime
    Bundler::Runtime.new(Bundler.root, new_definition)
  end

  # Generates a new Definition from the Gemfile and Lockfile. Ensures that there is no cached Definition.
  # @param [Hash, Boolean, nil] unlock Gems that have been requested to be updated or true if all gems should be updated
  # @return [Bundler::Definition]
  def new_definition(unlock = nil)
    Bundler::Definition.build(Bundler.default_gemfile, Bundler.default_lockfile, unlock)
  end

  # @return [Boolean] Whether the gem is present in the load path. Uses the instance variable @gem.
  def in_load_path?
    $LOAD_PATH.any? {|path| path.include? @gem}
  end

end
